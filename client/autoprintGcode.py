#!/usr/bin/env python3
"""
Bambu Lab Z-Pulsing Autoprint System

This module provides complete functionality for generating G-code that pulses the Z-axis,
packaging it into .3mf format, uploading to Bambu Lab printers, and capturing images
during the print process.

CRITICAL: Uses ONLY bambulabs_api library for all printer communication.
"""

from __future__ import annotations

import io
import logging
import time
import zipfile
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

try:
    import bambulabs_api as bl
    from PIL import Image
except ImportError as e:
    raise ImportError(
        f"Required dependencies not installed: {e}\n"
        "Install with: pip install bambulabs-api Pillow"
    )

log = logging.getLogger(__name__)


@dataclass
class CapturePoint:
    """Represents a single image capture point during the print"""
    pulse_number: int
    position: str  # "bottom" or "top"
    timestamp_seconds: float
    filename: str


@dataclass
class ZPulseConfig:
    """Configuration for Z-pulsing autoprint job

    Attributes:
        pulse_distance_mm: Distance to move bed in mm (default: 5.0)
        num_pulses: Number of complete pulse cycles (default: 40)
        dwell_time_seconds: Dwell time at each position in seconds (default: 3.0)
        feed_rate_z: Z-axis feed rate in mm/min (default: 300.0)
        capture_offset_seconds: Time offset into dwell for capture (default: 2.6)
        home_before_start: Whether to home printer before starting (default: True)
    """
    pulse_distance_mm: float = 5.0
    num_pulses: int = 40
    dwell_time_seconds: float = 3.0
    feed_rate_z: float = 300.0
    capture_offset_seconds: float = 2.6
    home_before_start: bool = True


def generate_zpulse_gcode(config: ZPulseConfig) -> str:
    """Generate complete G-code for Z-axis pulsing

    Generates G-code that:
    - Homes printer (optional)
    - Switches to relative positioning
    - Executes N pulses, each with:
      * Dwell at bottom position
      * Move bed down (Z up)
      * Dwell at top position
      * Move bed up (Z down)
    - Returns to absolute positioning

    Args:
        config: ZPulseConfig object with pulse parameters

    Returns:
        Complete G-code as multi-line string
    """
    lines = []

    # Header comment
    lines.append("; Bambu Lab Z-Pulse G-code")
    lines.append(f"; Generated by autoprintGcode.py")
    lines.append(f"; Pulses: {config.num_pulses}")
    lines.append(f"; Distance: {config.pulse_distance_mm}mm")
    lines.append(f"; Dwell: {config.dwell_time_seconds}s")
    lines.append(f"; Feed rate: {config.feed_rate_z}mm/min")
    lines.append("")

    # Home if requested
    if config.home_before_start:
        lines.append("; Home all axes")
        lines.append("G28")
        lines.append("")

    # Switch to relative positioning
    lines.append("; Switch to relative positioning")
    lines.append("G91")
    lines.append("")

    # Set Z feedrate
    lines.append(f"; Set Z feedrate to {config.feed_rate_z}mm/min")
    lines.append(f"G1 F{config.feed_rate_z}")
    lines.append("")

    # Generate pulse sequences
    for pulse_num in range(1, config.num_pulses + 1):
        lines.append(f"; Pulse {pulse_num}/{config.num_pulses}")

        # Dwell at bottom position (CAPTURE IMAGE HERE)
        lines.append(f"G4 S{config.dwell_time_seconds}")

        # Move bed DOWN (Z axis UP in relative mode)
        lines.append(f"G0 Z{config.pulse_distance_mm}")
        lines.append("M400  ; Wait for moves to complete")

        # Dwell at top position (CAPTURE IMAGE HERE)
        lines.append(f"G4 S{config.dwell_time_seconds}")

        # Move bed UP (Z axis DOWN in relative mode)
        lines.append(f"G0 Z-{config.pulse_distance_mm}")
        lines.append("M400  ; Wait for moves to complete")

        lines.append("")

    # Return to absolute positioning
    lines.append("; Return to absolute positioning")
    lines.append("G90")
    lines.append("")

    # Final flush
    lines.append("; Final flush")
    lines.append("M400")
    lines.append("")

    # End comment
    lines.append("; Z-Pulse sequence complete")

    return "\n".join(lines)


def calculate_capture_points(config: ZPulseConfig) -> List[CapturePoint]:
    """Calculate precise timing for image captures during print

    Calculates timestamps for capturing images during each dwell period,
    accounting for:
    - Homing time (if enabled)
    - Movement time between positions
    - Dwell time at each position

    Args:
        config: ZPulseConfig object with pulse parameters

    Returns:
        List of CapturePoint objects with timestamps and filenames
    """
    capture_points: List[CapturePoint] = []

    # Constants for timing calculations
    HOMING_TIME_SECONDS = 10.0

    # Calculate movement time for one pulse
    # time = distance / (feedrate / 60)
    move_time_seconds = (config.pulse_distance_mm / (config.feed_rate_z / 60.0))

    # Start time accounting for homing
    current_time = HOMING_TIME_SECONDS if config.home_before_start else 0.0

    # Generate capture points for each pulse
    for pulse_num in range(1, config.num_pulses + 1):
        # Bottom position capture
        bottom_capture_time = current_time + config.capture_offset_seconds
        capture_points.append(CapturePoint(
            pulse_number=pulse_num,
            position="bottom",
            timestamp_seconds=bottom_capture_time,
            filename=f"pulse_{pulse_num:03d}_bottom.jpg"
        ))

        # Advance time: dwell + move up
        current_time += config.dwell_time_seconds + move_time_seconds

        # Top position capture
        top_capture_time = current_time + config.capture_offset_seconds
        capture_points.append(CapturePoint(
            pulse_number=pulse_num,
            position="top",
            timestamp_seconds=top_capture_time,
            filename=f"pulse_{pulse_num:03d}_top.jpg"
        ))

        # Advance time: dwell + move down
        current_time += config.dwell_time_seconds + move_time_seconds

    log.info(f"Calculated {len(capture_points)} capture points")
    log.debug(f"Total estimated time: {current_time:.1f} seconds")

    return capture_points


def package_gcode_to_3mf(gcode_text: str, plate_number: int = 1) -> bytes:
    """Package G-code into .3mf archive format

    Creates a minimal .3mf file (ZIP format) containing the G-code.
    Bambu Lab printers require G-code to be packaged in this format.

    Args:
        gcode_text: Complete G-code as string
        plate_number: Plate number for the G-code (default: 1)

    Returns:
        .3mf file content as bytes

    Raises:
        ValueError: If gcode_text is empty or plate_number is invalid
    """
    if not gcode_text or not gcode_text.strip():
        raise ValueError("G-code text cannot be empty")

    if plate_number < 1:
        raise ValueError(f"Plate number must be >= 1, got {plate_number}")

    # Create in-memory ZIP file
    buffer = io.BytesIO()

    with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
        # Add G-code to the archive
        gcode_path = f"Metadata/plate_{plate_number}.gcode"
        zf.writestr(gcode_path, gcode_text)

        log.debug(f"Packaged G-code into .3mf: {len(gcode_text)} bytes -> {gcode_path}")

    # Get the bytes
    threemf_bytes = buffer.getvalue()
    log.info(f"Created .3mf package: {len(threemf_bytes)} bytes")

    return threemf_bytes


class BambuAutoPrinter:
    """Handle Bambu printer connection and autoprint execution

    This class manages all printer communication using ONLY the bambulabs_api library.
    It provides methods for:
    - Connecting to printer
    - Uploading and starting prints
    - Capturing camera images
    - Monitoring print status

    Attributes:
        ip: Printer IP address
        serial: Printer serial number
        access_code: Printer access code
        connect_camera: Whether to connect camera (default: True)
    """

    def __init__(
        self,
        ip: str,
        serial: str,
        access_code: str,
        connect_camera: bool = True
    ):
        """Initialize BambuAutoPrinter

        Args:
            ip: Printer IP address
            serial: Printer serial number
            access_code: Printer access code (8 digits)
            connect_camera: Whether to enable camera connection
        """
        self.ip = ip
        self.serial = serial
        self.access_code = access_code
        self.connect_camera = connect_camera
        self.printer: Optional[bl.Printer] = None
        self._connected = False

        log.info(f"Initialized BambuAutoPrinter for {ip} (serial: {serial})")

    def connect(self) -> None:
        """Connect to printer via bambulabs_api

        Establishes connection to the printer. If connect_camera is True,
        uses connect() method, otherwise uses mqtt_start().

        Raises:
            RuntimeError: If already connected
            ConnectionError: If connection fails
        """
        if self._connected and self.printer is not None:
            log.warning("Already connected to printer")
            return

        try:
            log.info(f"Connecting to printer at {self.ip}...")
            self.printer = bl.Printer(self.ip, self.access_code, self.serial)

            if self.connect_camera:
                log.info("Connecting with camera support...")
                self.printer.connect()
            else:
                log.info("Connecting without camera...")
                self.printer.mqtt_start()

            self._connected = True
            log.info("Successfully connected to printer")

        except Exception as e:
            log.error(f"Failed to connect to printer: {e}")
            raise ConnectionError(f"Failed to connect to printer at {self.ip}: {e}")

    def disconnect(self) -> None:
        """Disconnect from printer

        Cleanly disconnects from the printer and releases resources.
        """
        if not self._connected or self.printer is None:
            log.debug("Not connected, nothing to disconnect")
            return

        try:
            log.info("Disconnecting from printer...")
            if self.connect_camera:
                self.printer.disconnect()
            else:
                self.printer.mqtt_stop()

            self._connected = False
            self.printer = None
            log.info("Disconnected from printer")

        except Exception as e:
            log.warning(f"Error during disconnect: {e}")

    def upload_and_start_print(
        self,
        threemf_bytes: bytes,
        filename: str,
        plate_number: int = 1,
        use_ams: bool = False
    ) -> bool:
        """Upload .3mf file and start print via bambulabs_api

        Args:
            threemf_bytes: .3mf file content as bytes
            filename: Filename for the upload (should end with .3mf)
            plate_number: Plate number to print (default: 1)
            use_ams: Whether to use AMS (default: False)

        Returns:
            True if successful, False otherwise

        Raises:
            RuntimeError: If not connected to printer
        """
        if not self._connected or self.printer is None:
            raise RuntimeError("Not connected to printer. Call connect() first.")

        try:
            # Save to temporary file for upload
            temp_path = Path("/tmp") / filename
            temp_path.write_bytes(threemf_bytes)

            log.info(f"Uploading {filename} ({len(threemf_bytes)} bytes)...")

            # Start print using bambulabs_api
            self.printer.start_print(
                filename=str(temp_path),
                plate_number=plate_number,
                use_ams=use_ams,
                flow_calibration=False
            )

            log.info(f"Successfully started print: {filename}")

            # Clean up temp file
            temp_path.unlink(missing_ok=True)

            return True

        except Exception as e:
            log.error(f"Failed to upload and start print: {e}")
            return False

    def capture_image(self, save_path: Path) -> bool:
        """Capture image from printer camera

        Args:
            save_path: Path where to save the captured image

        Returns:
            True if successful, False otherwise

        Raises:
            RuntimeError: If not connected or camera not available
        """
        if not self._connected or self.printer is None:
            raise RuntimeError("Not connected to printer. Call connect() first.")

        if not self.connect_camera:
            log.warning("Camera not enabled for this connection")
            return False

        try:
            # Get image from camera
            image: Image.Image = self.printer.get_camera_image()

            # Save image
            save_path.parent.mkdir(parents=True, exist_ok=True)
            image.save(save_path, quality=95)

            log.debug(f"Captured image: {save_path}")
            return True

        except Exception as e:
            log.warning(f"Failed to capture image: {e}")
            return False

    def get_print_status(self) -> Dict[str, Any]:
        """Get current print status from printer

        Returns:
            Dictionary with status information including:
            - state: Current printer state
            - percentage: Print completion percentage
            - bed_temp: Current bed temperature
            - nozzle_temp: Current nozzle temperature

        Raises:
            RuntimeError: If not connected to printer
        """
        if not self._connected or self.printer is None:
            raise RuntimeError("Not connected to printer. Call connect() first.")

        try:
            status = {
                "state": self.printer.get_state(),
                "percentage": self.printer.get_percentage(),
                "bed_temp": self.printer.get_bed_temperature(),
                "nozzle_temp": self.printer.get_nozzle_temperature()
            }
            return status

        except Exception as e:
            log.warning(f"Failed to get print status: {e}")
            return {
                "state": "unknown",
                "percentage": 0,
                "bed_temp": 0,
                "nozzle_temp": 0
            }


def run_autoprint_job(
    ip: str,
    serial: str,
    access_code: str,
    output_dir: Path,
    config: Optional[ZPulseConfig] = None,
    monitor_progress: bool = True,
    generate_only: bool = False
) -> None:
    """Execute complete autoprint job with monitoring

    This is the main entry point for running a complete Z-pulsing autoprint job.
    It handles:
    1. G-code generation
    2. .3mf packaging
    3. Printer connection
    4. Upload and start print
    5. Image capture during print
    6. Status monitoring

    Args:
        ip: Printer IP address
        serial: Printer serial number
        access_code: Printer access code
        output_dir: Directory for output files
        config: ZPulseConfig object (uses defaults if None)
        monitor_progress: Whether to monitor and log print progress
        generate_only: If True, only generate files without connecting to printer

    Raises:
        ValueError: If parameters are invalid
        ConnectionError: If cannot connect to printer
        RuntimeError: If print fails to start
    """
    # Use default config if not provided
    if config is None:
        config = ZPulseConfig()

    # Ensure output directory exists
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    log.info("=" * 60)
    log.info("Starting Bambu Lab Z-Pulse Autoprint Job")
    log.info("=" * 60)
    log.info(f"Output directory: {output_dir}")
    log.info(f"Pulses: {config.num_pulses}")
    log.info(f"Distance: {config.pulse_distance_mm}mm")
    log.info(f"Dwell time: {config.dwell_time_seconds}s")
    log.info(f"Feed rate: {config.feed_rate_z}mm/min")

    # Step 1: Generate G-code
    log.info("\n[1/6] Generating G-code...")
    gcode_text = generate_zpulse_gcode(config)
    gcode_path = output_dir / "zpulse.gcode"
    gcode_path.write_text(gcode_text)
    log.info(f"✓ G-code saved: {gcode_path}")

    # Step 2: Calculate capture points
    log.info("\n[2/6] Calculating capture points...")
    capture_points = calculate_capture_points(config)
    log.info(f"✓ {len(capture_points)} capture points calculated")

    # Step 3: Package into .3mf
    log.info("\n[3/6] Packaging into .3mf format...")
    threemf_bytes = package_gcode_to_3mf(gcode_text, plate_number=1)
    threemf_path = output_dir / "zpulse.3mf"
    threemf_path.write_bytes(threemf_bytes)
    log.info(f"✓ .3mf package saved: {threemf_path}")

    # If generate-only mode, stop here
    if generate_only:
        log.info("\n" + "=" * 60)
        log.info("Generate-only mode: Files created successfully")
        log.info(f"G-code: {gcode_path}")
        log.info(f"3MF: {threemf_path}")
        log.info("=" * 60)
        return

    # Step 4: Connect to printer
    log.info(f"\n[4/6] Connecting to printer at {ip}...")
    printer = BambuAutoPrinter(ip, serial, access_code, connect_camera=True)

    try:
        printer.connect()
        log.info("✓ Connected to printer")

        # Step 5: Upload and start print
        log.info("\n[5/6] Uploading and starting print...")
        success = printer.upload_and_start_print(
            threemf_bytes=threemf_bytes,
            filename="zpulse.3mf",
            plate_number=1,
            use_ams=False
        )

        if not success:
            raise RuntimeError("Failed to start print")

        log.info("✓ Print started successfully")

        # Step 6: Monitor and capture images
        log.info(f"\n[6/6] Monitoring print and capturing images...")
        log.info(f"Will capture {len(capture_points)} images")

        start_time = time.time()
        capture_index = 0
        images_captured = 0

        while capture_index < len(capture_points):
            current_time = time.time() - start_time
            capture_point = capture_points[capture_index]

            # Check if it's time to capture
            if current_time >= capture_point.timestamp_seconds:
                image_path = output_dir / capture_point.filename

                if printer.capture_image(image_path):
                    images_captured += 1
                    log.info(
                        f"✓ Captured [{images_captured}/{len(capture_points)}]: "
                        f"{capture_point.filename} (pulse {capture_point.pulse_number}, "
                        f"{capture_point.position})"
                    )
                else:
                    log.warning(f"✗ Failed to capture: {capture_point.filename}")

                capture_index += 1

            # Monitor progress periodically
            if monitor_progress and int(current_time) % 10 == 0:
                status = printer.get_print_status()
                log.debug(
                    f"Status: {status['state']} - {status['percentage']}% - "
                    f"Bed: {status['bed_temp']}°C - Nozzle: {status['nozzle_temp']}°C"
                )

            # Small sleep to avoid busy waiting
            time.sleep(0.1)

        log.info(f"\n✓ Print monitoring complete!")
        log.info(f"Captured {images_captured}/{len(capture_points)} images")

    except Exception as e:
        log.error(f"\n✗ Error during autoprint job: {e}")
        raise

    finally:
        # Always disconnect
        printer.disconnect()
        log.info("\n" + "=" * 60)
        log.info("Autoprint job complete")
        log.info("=" * 60)


if __name__ == "__main__":
    # Simple test when run directly
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )

    print("Bambu Lab Autoprint G-code Generator")
    print("=" * 60)
    print("\nGenerating test G-code...")

    config = ZPulseConfig(num_pulses=5)
    gcode = generate_zpulse_gcode(config)

    print("\nGenerated G-code:")
    print("-" * 60)
    print(gcode)
    print("-" * 60)

    print(f"\nG-code length: {len(gcode)} characters")
    print(f"Lines: {len(gcode.splitlines())}")

    print("\n✓ Test complete")
